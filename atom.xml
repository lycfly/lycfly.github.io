<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>理想乡</title>
  
  <subtitle>LYC&#39;s Playgrand</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-19T09:44:37.982Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LYC</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习——数据集划分法</title>
    <link href="http://yoursite.com/2019/01/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86%E6%B3%95/"/>
    <id>http://yoursite.com/2019/01/11/机器学习——数据集划分法/</id>
    <published>2019-01-11T09:16:57.000Z</published>
    <updated>2019-01-19T09:44:37.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习——数据集划分法"><a href="#机器学习——数据集划分法" class="headerlink" title="机器学习——数据集划分法"></a>机器学习——数据集划分法</h1><p>[TOC]</p><hr><blockquote><p>——周志华老师机器学习西瓜书的一些总结与备忘。<a id="more"></a></p></blockquote><h2 id="2-2训练与测试集的划分"><a href="#2-2训练与测试集的划分" class="headerlink" title="2.2训练与测试集的划分"></a>2.2训练与测试集的划分</h2><h3 id="2-2-1留出法-hold-out"><a href="#2-2-1留出法-hold-out" class="headerlink" title="2.2.1留出法 (hold-out)"></a>2.2.1留出法 (hold-out)</h3><p><img src="/2019/01/11/机器学习——数据集划分法/2.png" alt=""></p><ul><li>常见做法是将大约 $2/3、 4/5$ 的样本用于训练，剩余样本用于测试。</li><li><p>需要注意测试与训练的样本分布要尽量相同。</p><h3 id="2-2-2-交叉验证法-K-fold-cross-validation"><a href="#2-2-2-交叉验证法-K-fold-cross-validation" class="headerlink" title="2.2.2 交叉验证法 (K-fold cross validation)"></a>2.2.2 交叉验证法 (K-fold cross validation)</h3><p><img src="/2019/01/11/机器学习——数据集划分法/3.png" alt=""></p></li><li><p>为减小 因样本划分不同而引入的差别 ， k 折交叉验证通常要随机使用不同的划分重复 p 次。最终的评估结果是这 p 次 k 折交叉验证结果的均值，例如常见的有10 次 10 折交叉验证。（实践中这么多折相当耗费计算能力，感觉不太会进行重复的k折取平均）</p><h3 id="2-2-3留一法-Leave-One-Out-LOO"><a href="#2-2-3留一法-Leave-One-Out-LOO" class="headerlink" title="2.2.3留一法 (Leave-One-Out , LOO)"></a>2.2.3留一法 (Leave-One-Out , LOO)</h3></li><li>假定数据集 D 中包含 m 个样本 , 若令 k=m ， 则得到了交叉验证法的 一个特例。 </li><li>留一法不受样本随机划分方式的影响。（每折只包含一个测试样本，与直接用D进行训练的结果相似）</li><li>感觉实际用途不大。。。先不说训练的时候往往是根据划分的交叉验证集上的测试结果来评定本次训练的优劣。因此验证集直接决定了每一折保存的是训练过程中的哪个模型。只留下一个样本作为交叉验证没有意义，除非有另外的测试集。如果是这种情况，还不如直接把所有数据都作为训练集。如果是为了使用K-fold融合多个模型提升效果，使用留一的方法过于极端，样本数量大时模型数量过多，样本较少时可以考虑。<h3 id="2-2-4-自助法-bootstrapping"><a href="#2-2-4-自助法-bootstrapping" class="headerlink" title="2.2.4 自助法 (bootstrapping)"></a>2.2.4 自助法 (bootstrapping)</h3></li><li><p>但在留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集小，这必然会引入一些因训练样本规模不同而导致的估计偏差。</p><p><img src="/2019/01/11/机器学习——数据集划分法/1.png" alt=""></p></li><li><p>自助法在数据集较小、难以有效划分训练/测试集时很有用</p></li><li><p>此外，自助法能从初始数据集中产生多个不同的训练集，这对集成学习等方法有很大的好处.</p></li><li><p>然而，自助法产生的数据集改变了初始数据集的分布，这会引入估计偏差.</p></li></ul><blockquote><p>参考《周志华机器学习西瓜书》第二章</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;机器学习——数据集划分法&quot;&gt;&lt;a href=&quot;#机器学习——数据集划分法&quot; class=&quot;headerlink&quot; title=&quot;机器学习——数据集划分法&quot;&gt;&lt;/a&gt;机器学习——数据集划分法&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;——周志华老师机器学习西瓜书的一些总结与备忘。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术文" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87/"/>
    
    
      <category term="机器学习(ML)" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-ML/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow之Summary用法总结</title>
    <link href="http://yoursite.com/2018/12/16/Tensorflow%E4%B9%8BSummary%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/16/Tensorflow之Summary用法总结/</id>
    <published>2018-12-16T13:05:08.000Z</published>
    <updated>2018-12-19T05:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tensorflow之Summary用法总结"><a href="#Tensorflow之Summary用法总结" class="headerlink" title="Tensorflow之Summary用法总结"></a>Tensorflow之Summary用法总结</h1><p>最近在研究tensorflow自带的例程speech_command,顺便学习tensorflow的一些基本用法。</p><p>其中tensorboard 作为一款可视化神器，可以说是学习tensorflow时模型训练以及参数可视化的法宝。</p><p>而在训练过程中，主要用到了tf.summary()的各类方法，能够保存训练过程以及参数分布图并在tensorboard显示。</p><a id="more"></a><h2 id="tf-summary包含的诸多函数"><a href="#tf-summary包含的诸多函数" class="headerlink" title="tf.summary包含的诸多函数"></a>tf.summary包含的诸多函数</h2><h3 id="1、tf-summary-scalar"><a href="#1、tf-summary-scalar" class="headerlink" title="1、tf.summary.scalar"></a>1、tf.summary.scalar</h3><p>用来显示标量信息，其格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.summary.scalar(tags, values, collections=<span class="keyword">None</span>, name=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>例如：tf.summary.scalar(‘mean’, mean)</p><p>一般在画loss,accuary时会用到这个函数。</p><h3 id="2、tf-summary-histogram"><a href="#2、tf-summary-histogram" class="headerlink" title="2、tf.summary.histogram"></a>2、tf.summary.histogram</h3><p>用来显示直方图信息，其格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf.summary.histogram(tags, values, collections=<span class="keyword">None</span>, name=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>例如： tf.summary.histogram(‘histogram’, var)</p><p>一般用来显示训练过程中变量的分布情况</p><h3 id="3、tf-summary-distribution"><a href="#3、tf-summary-distribution" class="headerlink" title="3、tf.summary.distribution"></a>3、tf.summary.distribution</h3><p>分布图，一般用于显示weights分布</p><h3 id="4、tf-summary-text"><a href="#4、tf-summary-text" class="headerlink" title="4、tf.summary.text"></a>4、tf.summary.text</h3><p>可以将文本类型的数据转换为tensor写入summary中：</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"""/a/b/c\\_d/f\\_g\\_h\\_2017"""</span></span><br><span class="line">summary_op0 = tf.summary.text(<span class="string">'text'</span>, tf.convert_to_tensor(text))</span><br></pre></td></tr></table></figure><h3 id="5、tf-summary-image"><a href="#5、tf-summary-image" class="headerlink" title="5、tf.summary.image"></a>5、tf.summary.image</h3><p>输出带图像的probuf，汇总数据的图像的的形式如下： ‘ tag /image/0’, ‘ tag /image/1’…，如：input/image/0等。</p><p>格式：tf.summary.image(tag, tensor, max_images=3, collections=None, name=Non</p><h3 id="6、tf-summary-audio"><a href="#6、tf-summary-audio" class="headerlink" title="6、tf.summary.audio"></a>6、tf.summary.audio</h3><p>展示训练过程中记录的音频 </p><h3 id="7、tf-summary-merge-all"><a href="#7、tf-summary-merge-all" class="headerlink" title="7、tf.summary.merge_all"></a>7、tf.summary.merge_all</h3><p>merge_all 可以将所有summary全部保存到磁盘，以便tensorboard显示。如果没有特殊要求，一般用这一句就可一显示训练时的各种信息了。</p><p>格式：tf.summaries.merge_all(key=’summaries’)</p><h3 id="8、tf-summary-FileWriter"><a href="#8、tf-summary-FileWriter" class="headerlink" title="8、tf.summary.FileWriter"></a>8、tf.summary.FileWriter</h3><p>指定一个文件用来保存图。</p><p>格式：tf.summary.FileWritter(path,sess.graph)</p><p>可以调用其add_summary（）方法将训练过程数据保存在filewriter指定的文件中</p><p>Tensorflow Summary 用法示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tf.summary.scalar(<span class="string">'accuracy'</span>,acc)                   <span class="comment">#生成准确率标量图  </span></span><br><span class="line">merge_summary = tf.summary.merge_all()  </span><br><span class="line">train_writer = tf.summary.FileWriter(dir,sess.graph)<span class="comment">#定义一个写入summary的目标文件，dir为写入文件地址  </span></span><br><span class="line">......(交叉熵、优化器等定义)  </span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> xrange(training_step):                  <span class="comment">#训练循环  </span></span><br><span class="line">    train_summary = sess.run(merge_summary,feed_dict =  &#123;...&#125;)<span class="comment">#调用sess.run运行图，生成一步的训练过程数据  </span></span><br><span class="line">    train_writer.add_summary(train_summary,step)<span class="comment">#调用train_writer的add_summary方法将训练过程以及训练步数保存</span></span><br></pre></td></tr></table></figure><p>此时开启tensorborad：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=/summary_dir</span><br></pre></td></tr></table></figure><p>便能看见accuracy曲线了。</p><p>另外，如果我不想保存所有定义的summary信息，也可以用tf.summary.merge方法有选择性地保存信息：</p><h3 id="9、tf-summary-merge"><a href="#9、tf-summary-merge" class="headerlink" title="9、tf.summary.merge"></a>9、tf.summary.merge</h3><p>格式：tf.summary.merge(inputs, collections=None, name=None)</p><p>一般选择要保存的信息还需要用到tf.get_collection()函数</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tf.summary.scalar(<span class="string">'accuracy'</span>,acc)                   <span class="comment">#生成准确率标量图  </span></span><br><span class="line">merge_summary = tf.summary.merge([tf.get_collection(tf.GraphKeys.SUMMARIES,<span class="string">'accuracy'</span>),...(其他要显示的信息)])  </span><br><span class="line">train_writer = tf.summary.FileWriter(dir,sess.graph)<span class="comment">#定义一个写入summary的目标文件，dir为写入文件地址  </span></span><br><span class="line">......(交叉熵、优化器等定义)  </span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> xrange(training_step):                  <span class="comment">#训练循环  </span></span><br><span class="line">    train_summary = sess.run(merge_summary,feed_dict =  &#123;...&#125;)<span class="comment">#调用sess.run运行图，生成一步的训练过程数据  </span></span><br><span class="line">    train_writer.add_summary(train_summary,step)<span class="comment">#调用train_writer的add_summary方法将训练过程以及训练步数保存</span></span><br></pre></td></tr></table></figure><p>使用tf.get_collection函数筛选图中summary信息中的accuracy信息，这里的</p><p>tf.GraphKeys.SUMMARIES  是summary在collection中的标志。</p><p>当然，也可以直接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acc_summary = tf.summary.scalar(<span class="string">'accuracy'</span>,acc)                   <span class="comment">#生成准确率标量图  </span></span><br><span class="line">merge_summary = tf.summary.merge([acc_summary ,...(其他要显示的信息)])  <span class="comment">#这里的[]不可省</span></span><br></pre></td></tr></table></figure><p> 如果要在tensorboard中画多个数据图，需定义多个tf.summary.FileWriter并重复上述过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tensorflow之Summary用法总结&quot;&gt;&lt;a href=&quot;#Tensorflow之Summary用法总结&quot; class=&quot;headerlink&quot; title=&quot;Tensorflow之Summary用法总结&quot;&gt;&lt;/a&gt;Tensorflow之Summary用法总结&lt;/h1&gt;&lt;p&gt;最近在研究tensorflow自带的例程speech_command,顺便学习tensorflow的一些基本用法。&lt;/p&gt;
&lt;p&gt;其中tensorboard 作为一款可视化神器，可以说是学习tensorflow时模型训练以及参数可视化的法宝。&lt;/p&gt;
&lt;p&gt;而在训练过程中，主要用到了tf.summary()的各类方法，能够保存训练过程以及参数分布图并在tensorboard显示。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87/"/>
    
    
      <category term="Tensorflow" scheme="http://yoursite.com/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下QQ的使用并手动设置QQ文件保存路径</title>
    <link href="http://yoursite.com/2018/12/16/Ubuntu%E4%B8%8BQQ%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B9%B6%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AEQQ%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2018/12/16/Ubuntu下QQ的使用并手动设置QQ文件保存路径/</id>
    <published>2018-12-16T12:51:26.000Z</published>
    <updated>2018-12-19T05:25:44.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景-amp-amp-目标"><a href="#背景-amp-amp-目标" class="headerlink" title="背景&amp;&amp;目标"></a>背景&amp;&amp;目标</h1><p>腾讯迟迟不肯做linux版本的QQ和微信，实在抠脚。<br>没有办法，要在linux上使用QQ，目前我找到最好的办法就是使用wine，然而wine这个杀千刀的又是个坑货，QQ除了聊天，还有最重要的功能就是传文件啊Orz,这货不但把路径隐藏了，还藏得这么深，，，无奈只能一层一层找，在用软连接链接出来。。。</p><a id="more"></a><p>下面主要以Ubuntu16.0.4为例，安装QQ,并手动设置文件保存路径。</p><h1 id="ubuntu下使用wine安装QQ"><a href="#ubuntu下使用wine安装QQ" class="headerlink" title="ubuntu下使用wine安装QQ"></a>ubuntu下使用wine安装QQ</h1><p> 主要参考 <a href="https://blog.csdn.net/hustcw98/article/details/79323024" target="_blank" rel="noopener">https://blog.csdn.net/hustcw98/article/details/79323024</a><br> 下载地址：<a href="http://yun.tzmm.com.cn/index.php/s/XRbfi6aOIjv5gwj" target="_blank" rel="noopener">http://yun.tzmm.com.cn/index.php/s/XRbfi6aOIjv5gwj</a><br> Appimage包不用做什么别的处理，安装啥的都不需要。。找到文件所在目录，终端中修改一下文件的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x QQ-20171129-x86_64.AppImage</span><br></pre></td></tr></table></figure><p>之后就可以直接运行了。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./QQ-20171129-x86_64.AppImage</span><br></pre></td></tr></table></figure><p> 然而作为深度windows依赖患者，自然不会习惯开个qq还要敲命令<br> 索性在把它固定到开始栏：<br> 首先把QQ-20171129-x86_64.AppImage 名字改的简单点，移动到linux下的/opt下：<br> 先cd到QQ-20171129-x86_64.AppImage所在路径，之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv QQ-20171129-x86_64.AppImage /opt/QQ</span><br></pre></td></tr></table></figure><p>再创建个启动器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /usr/share/applications/QQ.desktop</span><br></pre></td></tr></table></figure><p>将以下内容复制进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry] </span><br><span class="line">Name=QQ</span><br><span class="line">Name[zh_CN]=QQ</span><br><span class="line">Exec=/opt/QQ</span><br><span class="line">Icon=/opt/QQ.png</span><br><span class="line">Terminal=false</span><br><span class="line">X-MultipleArgs=false</span><br><span class="line">Type=Application</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Categories=Application;</span><br><span class="line">StartupNotify=false</span><br></pre></td></tr></table></figure><p>其中，QQ.png图标可以从网上随便找一个图标放到/opt或者随便什么路径，只要desktop里填写正确路径即可。<br> 如此QQ就可以像windows里一样打开了，可能还要手动固定到任务栏，这个就不提了。</p><h1 id="创建QQ文件保存路径"><a href="#创建QQ文件保存路径" class="headerlink" title="创建QQ文件保存路径"></a>创建QQ文件保存路径</h1><p>这种方法安装的QQ实际是基于wine的。。。如果你在里面接收文件，想要找到路径，这货显示的是windows里一样的路径，还有什么还有“我的电脑”。。。linux里哪来这玩意<br> 所以实际他把存的文件放在了一个隐藏文件夹里，在home/你的用户名 目录下按CTRL+h 显示隐藏文件，找到里面一个叫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.QQ.unionfs</span><br></pre></td></tr></table></figure><p>的文件夹，从QQ里接到的文件都放在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.QQ.unionfs/drive_c/users/你的用户名/My Documents/Tencent Files</span><br></pre></td></tr></table></figure><p>文件下了。<br> 所以可以在自己在外面创建一个该文件夹的软连接，方便找文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /home/你的用户名/.QQ.unionfs/drive_c/users/你的用户名/My\ Documents/Tencent\ Files /home/你的用户名/</span><br></pre></td></tr></table></figure><p>大功告成！如此便可在linux下愉快的使用QQ了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景-amp-amp-目标&quot;&gt;&lt;a href=&quot;#背景-amp-amp-目标&quot; class=&quot;headerlink&quot; title=&quot;背景&amp;amp;&amp;amp;目标&quot;&gt;&lt;/a&gt;背景&amp;amp;&amp;amp;目标&lt;/h1&gt;&lt;p&gt;腾讯迟迟不肯做linux版本的QQ和微信，实在抠脚。&lt;br&gt;没有办法，要在linux上使用QQ，目前我找到最好的办法就是使用wine，然而wine这个杀千刀的又是个坑货，QQ除了聊天，还有最重要的功能就是传文件啊Orz,这货不但把路径隐藏了，还藏得这么深，，，无奈只能一层一层找，在用软连接链接出来。。。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E6%96%87/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
</feed>
